<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  stroke: #fff;
  stroke-width: 2px;
}

.link {
  fill: none;
  stroke: #000;
}

</style>

<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<!-- <script src="~/d3/d3.v3.js"></script> -->
<div id="controls">
<button id="mark" onclick="toggleMarked()">mark/unmark ancestors</button>
<button id="extinct" onclick="toggleExtinct()">hide/show extinct</button>
<button id="create" onclick="makeGenealogy()">new genealogy:</button>
population size: <select id="popsize"></select>
generations: <select id="generations"></select>
<button id="print" onclick="printGenealogy()">print</button>
</div>

<script>
// var width  = 960, height = 500; // for gist
var width  = 800, height = 600;    // probably good for presentations

var popsize = 20;     // default value--might be changed by user.
var maxpopsize = 40;
var generations = 25;
var mingenerations = 3;
var maxgenerations = 40;

var toggleMarked, toggleExtinct;
var ancdata, ancestorsMarked, extinctHidden;

// NOTE: dnodes refers to the *data* tree nodes, i.e. individuals in generations (except for the hidden, root node). (What Bostock calls "nodes".)
//       snodes refers to the *svg* tree nodes (g's containing circles).  (What Bostock calls "node".)
var dnodes, snodes;

//// set up SVG area
var svg = d3.select("body").insert("svg", "#controls")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("transform", "translate(10,10)");

//// set up controls div
d3.select("#controls").style({"width":(width+"px"), "text-align":"center"});

///// set up population size dropdown
var popsizeControl = d3.select("#popsize");

popsizeControl.selectAll("option")    // add numeric options
    .data(d3.range(1,maxpopsize+1))
    .enter()
    .append("option")
    .text(function (d) {return d;});

popsizeControl
    .property("value", popsize)  // default value
    .on("change", function (d) {popsize = this.value;}); // action

///// set up generations dropdown
var generationsControl = d3.select("#generations");

generationsControl.selectAll("option")    // add numeric options
    .data(d3.range(mingenerations, maxgenerations+1))
    .enter()
    .append("option")
    .text(function (d) {return d;});

generationsControl
    .property("value", generations)  // default value
    .on("change", function (d) {generations = this.value;}); // action

makeGenealogy();

//toggleMarked(); // for gist

///// End of top-level "working code" in this file.
////////////////////////////////////////////////

function makeGenealogy () {
    /////////////////////////////////////////////////////////////////////
    // Top-level "working code within the makeGenerationData function" begins.  Outside of this region, only function defs (which of course do a lot of work).
    ancdata = undefined;
    ancestorsMarked = false;
    extinctHidden = false;

    svg.selectAll("*").remove(); // clear out contents of svg from any preceding call to this function

    var tree = d3.layout.tree()
        .size([width - 20, height - 20])
        .separation(function (a, b) {return a.parent == b.parent ? 7 : 10;}); // does this work??

    // initialize genealogy data structures
    var root = {id:0};
    dnodes = tree.nodes(root);
    root.parent = root;
    root.px = root.x;
    root.py = root.y;

    snodes = svg.selectAll(".node"),
    slinks = svg.selectAll(".link");

    // build the genealogy data in a loop
    for (k = 0; k < generations; k++) {
        makeGenerationData();
    }

    // create the svg based on the data
    displayGenealogy(root, tree);

    ///// End of "working code" in the makeGenealogy() function.
    ///// The rest of this contains only function definitions and a few variable
    ///// defs used in the functions below.
    /////////////////////////////////////////////////////////////////////

    function makeGenerationData() {
        var gennum = Math.max.apply(Math, dnodes.map(function(d){return d.depth;}));
        var currgen = generation(gennum);

        // Randomly create exactly popsize children
        for (i=0; i < popsize; i++) {
            var n = {id: dnodes.length},
                p = currgen[Math.random() * currgen.length | 0]; // ?: * binds tighter than 0. This gives random int in [0,dnodes.length).
            if (p.children) p.children.push(n); else p.children = [n];
            dnodes.push(n);
        }

        // Recompute the layout and data join.
        tree.nodes(root);
        tree.links(dnodes);
    }
}

function displayGenealogy(root, tree){
    // Recompute the layout and data join:
    snodes = snodes.data(tree.nodes(root), function(d) { return d.id; }) // needed as separate step so toplevel snodes is right

    snodes.enter()
        .append("circle")
        .attr("class", "node")
        .attr("r", 4)
        .attr("cx", function(d) { return d.px = d.x; })  // Note that in addition to placing the nodes, these modify data,
        .attr("cy", function(d) { return d.py = d.y; }) // assigning x to px, etc. This must happen before call to line() below.
	    .attr("opacity", function (d) {return d.depth === 0 ? 0 : 1;}); // we don't want root node, so just make it invisible (note Safari flashes it on momentarily)

    // Recompute the layout and data join:
    slinks = slinks.data(tree.links(dnodes), function(d) { return d.source.id + "-" + d.target.id; }); // needed as separate step so toplevel slinks is right

    slinks.enter().insert("path", ".node")
        .attr("class", "link")
        .attr("d", line)  // Note line() is a function defined above/below.  Depends on d.px = d.x, etc. above
	    .attr("opacity", function (d) {return d.source.depth === 0 ? 0 : 1;});
}

function generation (n) {
    return dnodes.filter(function (d) {return d.depth === n;});
}

function ancestors (currnodes, stop, accnodes, acclinks) {
   var newlinks = slinks.data().filter(function (d) {return currnodes.indexOf(d.target) !== -1;}); // links whose target node can be found in nods.
   var newnodes = newlinks.map(function (d) {return d.source;});

   if (stop(newnodes)) {
       return [accnodes.concat(newnodes), acclinks.concat(newlinks)];
   } else {
       return ancestors(newnodes, stop, accnodes.concat(newnodes), acclinks.concat(newlinks));
   }
}

function fillAncData (){
  var gennum = Math.max.apply(Math, dnodes.map(function(d){return d.depth;}));
  var currgen = generation(gennum);
  ancdata = ancestors(currgen, function(ns){return ns[0].depth <= 1;}, currgen, []);
}

function markAncestors () {
    if (!ancdata)
        fillAncData();
    snodes.data(ancdata[0], function(d){return d.id;})
        .style("fill", "red");
    slinks.data(ancdata[1], function(d){return d.source.id + "-" + d.target.id;})
        .style("stroke-width", "2")
        .style("stroke", "red");
}

function unmarkAncestors () {
    if (!ancdata)
        fillAncData();
    snodes.data(ancdata[0], function(d){return d.id;})
        .style("fill", "black");
    slinks.data(ancdata[1], function(d){return d.source.id + "-" + d.target.id;})
        .style("stroke-width", "1")
        .style("stroke", "black");
}

function hideExtinct () {
    if (!ancdata)
        fillAncData();
    snodes.data(ancdata[0], function(d){return d.id;})
        .exit()
	.attr("opacity", 0);
    slinks.data(ancdata[1], function(d){return d.source.id + "-" + d.target.id;})
        .exit()
	.attr("opacity", 0);
}

function unhideExtinct () {
    if (!ancdata)
        fillAncData(); // should be redundant
    snodes.data(ancdata[0], function(d){return d.id;})
        .exit()
        .attr("opacity", function (d) {return d.depth === 0 ? 0 : 1;}); // see note above
    slinks.data(ancdata[1], function(d){return d.source.id + "-" + d.target.id;})
        .exit()
        .attr("opacity", function (d) {return d.source.depth === 0 ? 0 : 1;});
}

// Drop-in straight-line replacement for diagonal() based on elusive-code's answer at http://stackoverflow.com/a/20116569/1455243:
function line(d){
    var linemaker = d3.svg.line().x( function(point) { return point.lx; })  // lx, ly are abitrary names
                                 .y( function(point) { return point.ly; }); // that are used in next lines.
    return linemaker([{lx: d.source.x, ly: d.source.y},
                      {lx: d.target.x, ly: d.target.y}]);
}

toggleMarked = function () {
    if (ancestorsMarked) {
        ancestorsMarked = false;
        unmarkAncestors();
    } else {
        ancestorsMarked = true;
        markAncestors();
    }
}

toggleExtinct = function () {
    if (extinctHidden) {
        extinctHidden = false;
        unhideExtinct();
    } else {
        extinctHidden = true;
        hideExtinct();
    }
}


function printGenealogy () {
    d3.select("#controls").style("visibility", "hidden");
    window.print();
    d3.select("#controls").style("visibility", "visible");
}

</script>
