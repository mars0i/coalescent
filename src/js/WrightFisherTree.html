<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  stroke: #fff;
  stroke-width: 2px;
}

.link {
  fill: none;
  stroke: #000;
}

</style>

<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<!-- <script src="~/d3/d3.v3.js"></script> -->
<div id="controls">
<button id="mark" onclick="toggleMarked()">mark/unmark ancestors</button>
<button id="extinct" onclick="toggleExtinct()">hide/show extinct</button>
<button id="mutate" onclick="mutate()">add mutations</button>
<button id="create" onclick="makeGenealogy()">new genealogy:</button>
population size: <select id="popsize"></select>
generations: <select id="generations"></select>
<button id="print" onclick="printGenealogy()">print</button>
</div>

<script>
// var width  = 960, height = 500; // for gist
var width  = 800, height = 600;    // probably good for presentations

var popsize = 20;     // default value--might be changed by user.
var maxpopsize = 40;
var generations = 25;
var mingenerations = 3;
var maxgenerations = 40;
var mutationRate = 0.05; // FIXME
var mutationColors = d3.scale.category20(),
    numMutationColors = 20;

var toggleMarked, toggleExtinct;
var ancdata, ancestorsMarked, extinctHidden;

// NOTE: dnodes refers to the *data* tree nodes, i.e. individuals in generations (except for the hidden, root node). (What Bostock calls "nodes".)
//       snodes refers to the *svg* tree nodes (g's containing circles).  (What Bostock calls "node".)
var dnodes, snodes, tree;

//// set up SVG area
var svg = d3.select("body").insert("svg", "#controls")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("transform", "translate(10,10)");

//// set up controls div
d3.select("#controls").style({"width":(width+"px"), "text-align":"center"});

///// set up population size dropdown
var popsizeControl = d3.select("#popsize");

popsizeControl.selectAll("option")    // add numeric options
    .data(d3.range(1,maxpopsize+1))
    .enter()
    .append("option")
    .text(function (d) {return d;});

popsizeControl
    .property("value", popsize)  // default value
    .on("change", function (d) {popsize = this.value;}); // action

///// set up generations dropdown
var generationsControl = d3.select("#generations");

generationsControl.selectAll("option")    // add numeric options
    .data(d3.range(mingenerations, maxgenerations+1))
    .enter()
    .append("option")
    .text(function (d) {return d;});

generationsControl
    .property("value", generations)  // default value
    .on("change", function (d) {generations = this.value;}); // action

makeGenealogy();
//toggleMarked(); // for gist

///// End of top-level "working code" in this file.
////////////////////////////////////////////////

function addRoot (tree) {
    var root = {id:0};
    var dnodes = tree.nodes(root);
    root.parent = root;
    root.px = root.x;
    root.py = root.y;
    return dnodes;
}

function makeTree () {
    return tree = d3.layout.tree()
        .size([width - 20, height - 20])
        .separation(function (a, b) {return a.parent == b.parent ? 7 : 10;}); // does this work??
}

function makeGenealogy () {

    // clear out vars, svg for new genealogy
    ancdata = undefined;
    ancestorsMarked = false;
    extinctHidden = false;
    svg.selectAll("*").remove(); // clear out contents of svg from any preceding call to this function

    tree = makeTree();

    dnodes = addRoot(tree);
    root = dnodes[0];

    // build the genealogy data in a loop
    for (k = 0; k < generations; k++) {
        makeGenerationData();
    }

    // create the svg based on the data
    displayGenealogy(root, tree);

    ///// End of "working code" in the makeGenealogy() function.
    ///// The rest of this contains only function definitions and a few variable
    ///// defs used in the functions below.
    /////////////////////////////////////////////////////////////////////

    function makeGenerationData() {
        var gennum = Math.max.apply(Math, dnodes.map(function(d){return d.depth;}));
        var currgen = generation(gennum);

        // Randomly create exactly popsize children
        for (i=0; i < popsize; i++) {
            var n = {id: dnodes.length},
                p = currgen[Math.random() * currgen.length | 0]; // ?: * binds tighter than 0. This gives random int in [0,dnodes.length).
            if (p.children) p.children.push(n); else p.children = [n];
            dnodes.push(n);
        }

        // Recompute the layout and data join.
        tree.nodes(root);
        tree.links(dnodes);
    }
}

function displayGenealogy(root, tree){
    snodes = svg.selectAll(".node"),
    slinks = svg.selectAll(".link");

    // Recompute the layout and data join:
    snodes = snodes.data(tree.nodes(root), function(d) { return d.id; }) // needed as separate step so toplevel snodes has correct value

    snodes.enter()
        .append("circle")
        .attr("class", "node")
        .attr("r", 4)
        .attr("cx", function(d) { return d.px = d.x; })  // Note that in addition to placing the nodes, these modify data,
        .attr("cy", function(d) { return d.py = d.y; })  // assigning x to px, etc. This must happen before call to line() below.
            .attr("opacity", function (d) {return d.depth === 0 ? 0 : 1;}); // we don't want root node, so just make it invisible (note Safari flashes it on momentarily)

    // (Notes: re the assignments d.px = d.x, etc. above in attr calls:
    // This assignment also returns the assigned value.
    // It's possible to move the assignment to a separate earlier step using snodes.each().
    // But then you *must* use d.x, d.y for the values of cx, cy.  px, py won't work.
    // Which doesn't make sense to me.  Maybe those get modified before that point, so
    // There actually is a reason to embed the assignments in the attr calls.)

    // Recompute the layout and data join:
    slinks = slinks.data(tree.links(dnodes), function(d) { return d.source.id + "-" + d.target.id; }); // needed as separate step so toplevel slinks has correct value

    slinks.enter().insert("path", ".node")
        .attr("class", "link")
        .attr("d", line)  // Note line() is a function defined above/below.  Depends on d.px = d.x, etc. above
            .attr("opacity", function (d) {return d.source.depth === 0 ? 0 : 1;});
}

function generation (n) {
    return dnodes.filter(function (d) {return d.depth === n;});
}

function ancestors (currnodes, stop, accnodes, acclinks) {
   var newlinks = slinks.data().filter(function (d) {return currnodes.indexOf(d.target) !== -1;}); // links whose target node can be found in nods.
   var newnodes = newlinks.map(function (d) {return d.source;});

   if (stop(newnodes)) {
       return {"nodes":accnodes.concat(newnodes), "links":acclinks.concat(newlinks)};
   } else {
       return ancestors(newnodes, stop, accnodes.concat(newnodes), acclinks.concat(newlinks));
   }
}

function fillAncData (){
    var gennum = Math.max.apply(Math, dnodes.map(function(d){return d.depth;}));
    var currgen = generation(gennum);
    ancdata = ancestors(currgen, function(ns){return ns[0].depth <= 1;}, currgen, []);
    ancdata.nodes.forEach(function (d) {d.isAncestral = true;});  // side-effects global data nodes
    ancdata.links.forEach(function (d) {d.isAncestral = true;});  // side-effects global data links
    root.isAncestral = true;                                   // side-effects global root
}

function toggleMarked () {
    if (ancestorsMarked) {
        ancestorsMarked = false;
        unmarkAncestors();
    } else {
        ancestorsMarked = true;
        markAncestors();
    }
}

function markAncestors () {
    if (!ancdata)
        fillAncData();
    snodes.data(ancdata.nodes, function(d){return d.id;})
        .style("fill", "red");
    slinks.data(ancdata.links, function(d){return d.source.id + "-" + d.target.id;})
        .style("stroke-width", "2")
        .style("stroke", "red");
}

function unmarkAncestors () {
    if (!ancdata)
        fillAncData();
    snodes.data(ancdata.nodes, function(d){return d.id;})
        .style("fill", "black");
    slinks.data(ancdata.links, function(d){return d.source.id + "-" + d.target.id;})
        .style("stroke-width", "1")
        .style("stroke", "black");
}

function toggleExtinct () {
    if (extinctHidden) {
        extinctHidden = false;
        unhideExtinct();
    } else {
        extinctHidden = true;
        hideExtinct();
    }
}

function hideExtinct () {
    if (!ancdata)
        fillAncData();
    snodes.data(ancdata.nodes, function(d){return d.id;})
        .exit()
        .attr("opacity", 0);
    slinks.data(ancdata.links, function(d){return d.source.id + "-" + d.target.id;})
        .exit()
        .attr("opacity", 0);
}

function unhideExtinct () {
    if (!ancdata)
        fillAncData(); // should be redundant
    snodes.data(ancdata.nodes, function(d){return d.id;})
        .exit()
        .attr("opacity", function (d) {return d.depth === 0 ? 0 : 1;}); // see note above
    slinks.data(ancdata.links, function(d){return d.source.id + "-" + d.target.id;})
        .exit()
        .attr("opacity", function (d) {return d.source.depth === 0 ? 0 : 1;});
}

// Drop-in straight-line replacement for diagonal() based on elusive-code's answer at http://stackoverflow.com/a/20116569/1455243:
function line(d){
    var linemaker = d3.svg.line().x( function(point) { return point.lx; })  // lx, ly are abitrary names
                                 .y( function(point) { return point.ly; }); // that are used in next lines.
    return linemaker([{lx: d.source.x, ly: d.source.y},
                      {lx: d.target.x, ly: d.target.y}]);
}

// inefficient ...
function mutate () {
    var mutation = 0;
    for (i = 1; i <= generations; i++) {
        dgen = generation(i);
        dgen.forEach(function (d) { // TODO This is not the right distribution.  It should be a Poisson process on branch lengths.
            if (Math.random() < mutationRate) {
                d.mutation = mutation++;
		propagateMutation(d);
            }
        });
    }

    snodes.data(dnodes.filter(function (d) {return d.mutation;}), function (d) {return d.id;})
        .style("fill", function (d) {return mutationColors(d.mutation % numMutationColors);});

    slinks.data(slinks.data().filter(function (d) {return d.source.mutation;}),
                function(d) {return d.source.id + "-" + d.target.id;})
        .style("stroke", function (d) {return mutationColors(d.source.mutation % numMutationColors);});
}

function propagateMutation (dnode) {
    if (dnode.children) {
        dnode.children.forEach(function (d) {
            d.mutation = dnode.mutation;
            propagateMutation(d);
        });
    }
}

function printGenealogy () {
    d3.select("#controls").style("visibility", "hidden");
    window.print();
    d3.select("#controls").style("visibility", "visible");
}

</script>
