<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  stroke: #fff;
  stroke-width: 2px;
}

.link {
  fill: none;
  stroke: #000;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<span id="controls">
<br/>
<button id="create" onclick="createTree()">new genealogy</button>
<button id="mark" onclick="toggleMarked()">mark/unmark ancestors</button>
<button id="extinct" onclick="toggleExtinct()">hide/show extinct</button>
</span>
<script>

var width = 800,
    height = 600;

var popsize = 20;
var maxgens = 27;
//var delay = 750;
var delay = 100;
//delay = 0; // DEBUG

var firsttick = true;

var tree, root, nodes;


//var diagonal = d3.svg.diagonal();

// Drop-in straight-line replacement for diagonal() based on
// elusive-code's answer at http://stackoverflow.com/a/20116569/1455243:
function line(d){
    var linemaker = d3.svg.line().x( function(point) { return point.lx; })
                                 .y( function(point) { return point.ly; });
    return linemaker([{lx: d.source.x, ly: d.source.y},
                      {lx: d.target.x, ly: d.target.y}]);
}

var svg = d3.select("body").insert("svg", "#controls")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("transform", "translate(10,10)");

var node = svg.selectAll(".node"),
    link = svg.selectAll(".link");

function createTree () {
    svg.selectAll("circle").remove();
    svg.selectAll("path").remove();

    tree = d3.layout.tree()
        .size([width - 20, height - 20])
        .separation(function (a, b) {return a.parent == b.parent ? 7 : 8;}); // does this work??
    
    root = {};
    nodes = tree.nodes(root);
    root.parent = root;
    root.px = root.x;
    root.py = root.y;

    for (j=0; j<=maxgens; j++) {
        update();
    }
}

function update() {
  var gennum = Math.max.apply(Math, nodes.map(function(d){return d.depth;}));
  var currgen = generation(gennum);

  // Randomly create exactly popsize children
  for (i=0; i < popsize; i++) {
      var n = {id: nodes.length},
          p = currgen[Math.random() * currgen.length | 0]; // ?: * binds tighter than 0. This gives random int in [0,nodes.length).
      if (p.children) p.children.push(n); else p.children = [n];
      nodes.push(n);
  }

  // Recompute the layout and data join.
  node = node.data(tree.nodes(root), function(d) { return d.id; });
  link = link.data(tree.links(nodes), function(d) { return d.source.id + "-" + d.target.id; });

  // Add entering nodes in the parent’s old position.
  node.enter()
      .append("circle")
      .attr("opacity", function (d) {return d.depth === 0 ? 0 : 1;}) // we don't want root node, so just make it invisible (note Safari flashes it on momentarily)
      .attr("class", "node")
      .attr("r", 4)
      .attr("cx", function(d) { return d.parent.px; })
      .attr("cy", function(d) { return d.parent.py; });

  // Add entering links in the parent’s old position.
  link.enter().insert("path", ".node")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: d.source.px, y: d.source.py};
        return line({source: o, target: o});
      })
      .attr("opacity", function (d) {return d.source.depth === 0 ? 0 : 1;}); // we don't want links to root node, so just make them invisible

  // Transition nodes and links to their new positions.
  var t = svg.transition()
      .delay(function() {
          if (firsttick) {         // kludge:
	      firsttick = false;   // Don't want to see generation 1 spread down from the gen 0 singleton,
	      return 0;            // so make its delay 0.
	  } else {
	      return delay;
	  }});

  t.selectAll(".link")
      .attr("d", line);  // Note line() is a function defined above/below.

  t.selectAll(".node")
      .attr("cx", function(d) { return d.px = d.x; })
      .attr("cy", function(d) { return d.py = d.y; });
}

function generation (n) {
    return nodes.filter(function (d) {return d.depth === n;});
}

function ancestors (currnodes, stop, accnodes, acclinks) {
   var newlinks = link.data().filter(function (d) {return currnodes.indexOf(d.target) !== -1;}); // links whose target node can be found in nods.
   var newnodes = newlinks.map(function (d) {return d.source;});

   if (stop(newnodes)) {
       return [accnodes.concat(newnodes), acclinks.concat(newlinks)];
   } else {
       return ancestors(newnodes, stop, accnodes.concat(newnodes), acclinks.concat(newlinks));
   }
}

var ancdata = undefined;
function fillAncData (){
  var gennum = Math.max.apply(Math, nodes.map(function(d){return d.depth;}));
  var currgen = generation(gennum);
  ancdata = ancestors(currgen, function(ns){return ns[0].depth <= 1;}, currgen, []);
}

var ancestorsMarked = false;
function toggleMarked () {
    if (ancestorsMarked) {
        ancestorsMarked = false;
        unmarkAncestors();
    } else {
        ancestorsMarked = true;
        markAncestors();
    }
}

function markAncestors () {
    if (!ancdata)
        fillAncData();
    node.data(ancdata[0], function(d){return d.id;})
        .style("fill", "red");
    link.data(ancdata[1], function(d){return d.source.id + "-" + d.target.id;})
        .style("stroke-width", "2")
        .style("stroke", "red");
}

function unmarkAncestors () {
    if (!ancdata)
        fillAncData();
    node.data(ancdata[0], function(d){return d.id;})
        .style("fill", "black");
    link.data(ancdata[1], function(d){return d.source.id + "-" + d.target.id;})
        .style("stroke-width", "1")
        .style("stroke", "black");
}

var extinctHidden = false;
function toggleExtinct () {
    if (extinctHidden) {
        extinctHidden = false;
        unhideExtinct();
    } else {
        extinctHidden = true;
        hideExtinct();
    }
}

function hideExtinct () {
    if (!ancdata)
        fillAncData();
    node.data(ancdata[0], function(d){return d.id;})
        .exit()
	.attr("opacity", 0);
    link.data(ancdata[1], function(d){return d.source.id + "-" + d.target.id;})
        .exit()
	.attr("opacity", 0);
}

function unhideExtinct () {
    if (!ancdata)
        fillAncData(); // should be redundant
    node.data(ancdata[0], function(d){return d.id;})
        .exit()
        .attr("opacity", function (d) {return d.depth === 0 ? 0 : 1;}); // see note above
    link.data(ancdata[1], function(d){return d.source.id + "-" + d.target.id;})
        .exit()
        .attr("opacity", function (d) {return d.source.depth === 0 ? 0 : 1;});
}

</script>
